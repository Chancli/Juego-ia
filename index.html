<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Configuración APP / PWA -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Neon Orbit: Juego Arcade de reflejos">
    <title>Neon Orbit: Sonic Trinity</title>

    <!-- ÍCONO SVG -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%23050505'/><circle cx='256' cy='256' r='200' stroke='%230ff' stroke-width='20' fill='none'/><circle cx='256' cy='256' r='120' stroke='%230ff' stroke-width='10' fill='none' opacity='0.5'/><circle cx='256' cy='100' r='30' fill='%230ff'/></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%23000'/><circle cx='256' cy='256' r='200' stroke='%230ff' stroke-width='20' fill='none'/><circle cx='256' cy='256' r='120' stroke='%230ff' stroke-width='10' fill='none' opacity='0.5'/><circle cx='256' cy='100' r='30' fill='%230ff'/></svg>">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #gameCanvas {
            display: block;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            box-sizing: border-box;
        }

        .score-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .score-display {
            color: #fff;
            font-size: 24px;
            text-shadow: 0 0 10px #0ff;
            z-index: 10;
            font-weight: bold;
        }

        .high-score {
            color: #aaa;
            font-size: 14px;
            margin-top: 5px;
        }

        .control-hints {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
            opacity: 0.3;
            font-size: 12px;
            color: #0ff;
            pointer-events: none;
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* Menus */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: auto;
            transition: opacity 0.3s;
            backdrop-filter: blur(5px);
            padding: 20px;
            box-sizing: border-box;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            color: #0ff;
            font-size: 36px;
            margin: 0 0 10px 0;
            text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
            text-align: center;
            letter-spacing: 4px;
            line-height: 1.1;
        }

        h1 span {
            font-size: 18px;
            color: #ff0055;
            letter-spacing: 8px;
        }

        p {
            color: #ccc;
            text-align: center;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.5;
            max-width: 90%;
        }

        .controls-info {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 11px;
            color: #888;
            width: 100%;
            justify-content: center;
        }
        .control-box {
            border: 1px solid #444;
            padding: 10px;
            border-radius: 5px;
            flex: 1;
            max-width: 120px;
            text-align: center;
        }

        /* AI Text Areas */
        .ai-text-box {
            min-height: 50px;
            width: 90%;
            max-width: 400px;
            margin-bottom: 20px;
            padding: 12px;
            border-left: 3px solid #0ff;
            background: rgba(0, 255, 255, 0.05);
            color: #dff;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: center;
            font-style: italic;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.1);
        }

        button {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 30px;
            font-size: 16px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transition: all 0.15s;
            border-radius: 4px;
            text-transform: uppercase;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        button:active {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff;
            transform: scale(0.96);
        }

        .ai-btn {
            font-size: 11px;
            padding: 8px 15px;
            border: 1px solid #a0f;
            color: #a0f;
            box-shadow: 0 0 5px #a0f;
            margin-bottom: 15px;
            background: rgba(100, 0, 255, 0.05);
        }
        
        .ai-btn:active {
            background: #a0f;
            color: #fff;
            box-shadow: 0 0 15px #a0f;
        }

        .loader {
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="score-container">
            <div class="score-display">SCORE: <span id="scoreEl">0</span></div>
            <div class="high-score">BEST: <span id="highScoreEl">0</span></div>
        </div>
        <div class="control-hints">
            <span>&lt; ADENTRO</span>
            <span>AFUERA &gt;</span>
        </div>
    </div>

    <!-- START MENU -->
    <div id="startMenu" class="menu-screen">
        <h1>NEON<br><span>TRINITY</span></h1>
        
        <div id="missionBox" class="ai-text-box">
            Sistema Online.<br>Esperando piloto...
        </div>
        <button id="generateMissionBtn" class="ai-btn">✨ GENERAR DIRECTIVA</button>

        <div class="controls-info">
            <div class="control-box">IZQUIERDA<br>Bajar</div>
            <div class="control-box">DERECHA<br>Subir</div>
        </div>

        <button id="startBtn">INICIAR SISTEMA</button>
    </div>

    <!-- GAME OVER MENU -->
    <div id="gameOverMenu" class="menu-screen hidden">
        <h1 style="color: #ff0055; text-shadow: 0 0 20px #ff0055; font-size: 32px;">ERROR CRÍTICO</h1>
        <p>Score Final: <span id="finalScore" style="color:#fff; font-weight:bold;">0</span></p>
        
        <button id="analyzeBtn" class="ai-btn" style="border-color: #ff0055; color: #ff0055; box-shadow: 0 0 5px #ff0055;">✨ ANÁLISIS DE IA</button>
        <div id="analysisBox" class="ai-text-box" style="display:none; border-left-color: #ff0055;">
            Procesando...
        </div>

        <button id="restartBtn" style="border-color: #ff0055; color: #ff0055; box-shadow: 0 0 15px #ff0055;">REINICIAR</button>
    </div>

    <script>
        // --- AUDIO SYSTEM ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;

        const soundManager = {
            init: function() {
                if (!audioCtx) {
                    audioCtx = new AudioContext();
                } else if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            playJump: function(high) {
                const f = high ? 600 : 300;
                this.playTone(f, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(f * 1.5, 'sine', 0.1, 0.05), 50);
            },
            playScore: function() {
                this.playTone(880, 'triangle', 0.1, 0.1);
                setTimeout(() => this.playTone(1760, 'sine', 0.2, 0.1), 50);
            },
            playCrash: function() {
                this.playTone(100, 'sawtooth', 0.5, 0.2);
                this.playTone(50, 'square', 0.5, 0.2);
            }
        };

        // --- SISTEMA DE "IA" OFFLINE (Base de datos local) ---
        
        const dbMissions = [
            "Sobrevive al flujo de datos corruptos.",
            "Mantén la sincronización orbital al 100%.",
            "Evita la colisión con los cortafuegos rojos.",
            "Recolecta fragmentos de código dorado.",
            "Supera el protocolo de seguridad del Núcleo.",
            "No dejes que el sistema te borre.",
            "Demuestra que no eres un bot.",
            "Alcanza la singularidad orbital."
        ];

        const dbWorse = [
            "Tu rendimiento ha decaído. Patético.",
            "¿Eso es todo? Lo hiciste mejor antes.",
            "El sistema detecta fatiga en tus reflejos.",
            "Degradación cognitiva detectada.",
            "Has empeorado. ¿Necesitas un reinicio?",
            "Tus algoritmos son ineficientes hoy.",
            "Decepcionante. Esperaba más de ti."
        ];

        const dbBetter = [
            "Mejora incremental detectada. Bien.",
            "Procesando... Has superado tu intento anterior.",
            "Reflejos optimizados. Continúa así.",
            "El aprendizaje automático está funcionando.",
            "No está mal, piloto. Vas mejorando.",
            "Sincronización superior a la anterior."
        ];

        const dbRecord = [
            "¡NUEVO RÉCORD DE SISTEMA! IMPRESIONANTE.",
            "¡CAPACIDAD MÁXIMA ALCANZADA! ERES EL MEJOR.",
            "¡Sobrecarga de habilidad! Has roto el historial.",
            "EL NÚCLEO TE RECONOCE COMO ADMINISTRADOR.",
            "¡Puntuación legendaria registrada!"
        ];

        const dbLow = [
            "Error de capa 8: Usuario incompetente.",
            "¿Estás intentando perder a propósito?",
            "Rendimiento sub-óptimo. Esfuérzate más.",
            "Ni siquiera has calentado los circuitos."
        ];

        // Variables de estado para la "IA"
        let lastScore = parseInt(localStorage.getItem('neonOrbitLastScore') || 0);

        // --- DOM ELEMENTS ---
        const missionBox = document.getElementById('missionBox');
        const generateMissionBtn = document.getElementById('generateMissionBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const analysisBox = document.getElementById('analysisBox');
        const startMenu = document.getElementById('startMenu');
        const gameOverMenu = document.getElementById('gameOverMenu');
        const scoreEl = document.getElementById('scoreEl');
        const highScoreEl = document.getElementById('highScoreEl');
        const finalScoreEl = document.getElementById('finalScore');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');

        // --- AI LOGIC HANDLERS ---
        generateMissionBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            soundManager.init();
            soundManager.playTone(440, 'sine', 0.1);
            missionBox.innerHTML = '<div class="loader"></div> Accediendo...';
            
            // Simular delay de red
            setTimeout(() => {
                const randomMission = dbMissions[Math.floor(Math.random() * dbMissions.length)];
                missionBox.innerText = `Directiva: ${randomMission}`;
            }, 600);
        });
        
        analyzeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            soundManager.init();
            analysisBox.style.display = 'flex';
            analysisBox.innerHTML = '<div class="loader"></div> Computando...';
            analyzeBtn.style.display = 'none';

            const currentScore = parseInt(finalScoreEl.innerText);
            const highScore = parseInt(localStorage.getItem('neonOrbitHighScore') || 0);
            // lastScore se actualiza al morir, así que comparamos con el valor antes de morir (stored)
            // Pero aquí lastScore ya se actualizó en gameOver(). Necesitamos una lógica temporal o comparar.
            
            // Lógica de selección de mensaje
            setTimeout(() => {
                let msg = "";
                
                // Si es récord (score actual == high score y es mayor que 0)
                if (currentScore >= highScore && currentScore > 0) {
                     msg = dbRecord[Math.floor(Math.random() * dbRecord.length)];
                }
                // Si es una puntuación muy baja (< 30)
                else if (currentScore < 30) {
                    msg = dbLow[Math.floor(Math.random() * dbLow.length)];
                }
                // Comparar con la anterior (Ojo: lastScore se actualiza al final del juego, 
                // usaremos una variable temporal guardada antes)
                else if (currentScore > tempPrevScore) {
                    msg = dbBetter[Math.floor(Math.random() * dbBetter.length)];
                } else {
                    msg = dbWorse[Math.floor(Math.random() * dbWorse.length)];
                }

                analysisBox.innerText = msg;
            }, 800);
        });

        // --- GAME LOGIC ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameState = 'MENU'; 
        let score = 0;
        let highScore = localStorage.getItem('neonOrbitHighScore') || 0;
        let tempPrevScore = lastScore; // Guardamos la puntuación anterior antes de sobreescribirla
        highScoreEl.innerText = highScore;
        let frames = 0;
        let spawnRate = 70; 
        let minSpawnRate = 20; 
        let centerX, centerY;
        const laneCount = 3; 
        let radii = []; 

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            const minDim = Math.min(canvas.width, canvas.height);
            radii = [minDim * 0.18, minDim * 0.30, minDim * 0.42];
        }
        window.addEventListener('resize', resize);
        resize();

        class Particle {
            constructor(x, y, color, speed, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.angle = Math.random() * Math.PI * 2;
                this.velocity = Math.random() * speed + 0.5;
                this.vx = Math.cos(this.angle) * this.velocity;
                this.vy = Math.sin(this.angle) * this.velocity;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 3 + 1;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.size *= 0.95;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Player {
            constructor() {
                this.angle = 0;
                this.lane = 1; 
                this.currentRadius = radii[1];
                this.targetRadius = radii[1];
                this.speed = 0.05; 
                this.color = '#00ffff';
                this.trail = [];
            }
            update() {
                this.angle += this.speed;
                this.targetRadius = radii[this.lane];
                this.currentRadius += (this.targetRadius - this.currentRadius) * 0.4;
                this.x = centerX + Math.cos(this.angle) * this.currentRadius;
                this.y = centerY + Math.sin(this.angle) * this.currentRadius;
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 10) this.trail.shift();
            }
            move(dir) {
                const prevLane = this.lane;
                this.lane += dir;
                if (this.lane < 0) this.lane = 0;
                if (this.lane >= laneCount) this.lane = laneCount - 1;
                if (this.lane !== prevLane) {
                    soundManager.playJump(dir > 0);
                    createExplosion(this.x, this.y, 'rgba(0,255,255,0.3)', 3);
                }
            }
            draw() {
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                for (let i = 0; i < this.trail.length; i++) {
                    const p = this.trail[i];
                    if (i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
                }
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Obstacle {
            constructor(angle, lane, type) {
                this.angle = angle;
                this.lane = lane;
                this.type = type; 
                this.active = true;
                this.pulse = 0;
            }
            update() {
                this.pulse += 0.15;
            }
            draw() {
                if (!this.active) return;
                const r = radii[this.lane];
                const x = centerX + Math.cos(this.angle) * r;
                const y = centerY + Math.sin(this.angle) * r;
                ctx.save();
                if (this.type === 'enemy') {
                    ctx.shadowBlur = 10 + Math.sin(this.pulse) * 5;
                    ctx.shadowColor = '#ff0055';
                    ctx.strokeStyle = '#ff0055';
                    ctx.fillStyle = '#550022';
                    ctx.lineWidth = 2;
                    ctx.translate(x, y);
                    ctx.rotate(this.angle + Math.PI / 4); 
                    const size = 10;
                    ctx.beginPath();
                    ctx.rect(-size/2, -size/2, size, size);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffcc00';
                    ctx.fillStyle = '#ffcc00';
                    const size = 5 + Math.sin(this.pulse) * 2;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        let player;
        let entities = [];
        let particles = [];
        let shake = 0;
        let spawnTimer = 0;

        function initGame() {
            soundManager.init();
            
            // Guardar estado de "partida anterior" para comparar luego
            tempPrevScore = parseInt(localStorage.getItem('neonOrbitLastScore') || 0);
            
            score = 0;
            frames = 0;
            spawnRate = 70; 
            scoreEl.innerText = score;
            player = new Player();
            entities = [];
            particles = [];
            gameState = 'PLAYING';
            startMenu.classList.add('hidden');
            gameOverMenu.classList.add('hidden');
            setTimeout(() => {
                analyzeBtn.style.display = 'block';
                analysisBox.style.display = 'none';
                analysisBox.innerHTML = '';
            }, 500);
        }

        function createExplosion(x, y, color, count = 15) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, 6, 25));
            }
        }

        function spawnEntities() {
            spawnTimer++;
            let currentRate = Math.max(minSpawnRate, 70 - (score * 0.8));
            if (spawnTimer > currentRate) {
                spawnTimer = 0;
                const lane = Math.floor(Math.random() * laneCount);
                const spawnAngle = player.angle + Math.PI; 
                const coinChance = Math.max(0.15, 0.3 - (score * 0.002));
                const type = Math.random() < coinChance ? 'coin' : 'enemy'; 
                entities.push(new Obstacle(spawnAngle, lane, type));
            }
        }

        function checkCollisions() {
            const playerHitbox = 14;
            const pDist = player.currentRadius;
            for (let i = entities.length - 1; i >= 0; i--) {
                const ent = entities[i];
                const entDist = radii[ent.lane];
                const radialDiff = Math.abs(pDist - entDist);
                if (radialDiff < 15) {
                    let pa = player.angle % (Math.PI * 2);
                    let ea = ent.angle % (Math.PI * 2);
                    if (pa < 0) pa += Math.PI * 2;
                    if (ea < 0) ea += Math.PI * 2;
                    let diff = Math.abs(pa - ea);
                    if (diff > Math.PI) diff = (Math.PI * 2) - diff;
                    const arcDist = diff * pDist;
                    if (arcDist < playerHitbox) {
                        if (ent.type === 'enemy') {
                            soundManager.playCrash();
                            createExplosion(player.x, player.y, '#ff0055', 50);
                            shake = 25;
                            gameOver();
                        } else if (ent.type === 'coin') {
                            soundManager.playScore();
                            createExplosion(player.x, player.y, '#ffcc00', 12);
                            score += 10;
                            scoreEl.innerText = score;
                            ent.active = false;
                            player.speed = Math.min(0.08, 0.05 + (score * 0.0001)); 
                        }
                    }
                }
                if (player.angle - ent.angle > Math.PI * 1.5) {
                    ent.active = false;
                }
            }
            entities = entities.filter(e => e.active);
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            finalScoreEl.innerText = score;
            
            // Guardar High Score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('neonOrbitHighScore', highScore);
                highScoreEl.innerText = highScore;
            }
            
            // Guardar Last Score (para comparaciones futuras)
            localStorage.setItem('neonOrbitLastScore', score);
            lastScore = score;

            setTimeout(() => gameOverMenu.classList.remove('hidden'), 500);
        }

        function update() {
            if (gameState !== 'PLAYING') {
                if (particles.length > 0 || shake > 0) draw();
                if (shake > 0) shake *= 0.9;
                return;
            }
            frames++;
            player.update();
            spawnEntities();
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);
            checkCollisions();
            if (shake > 0) shake *= 0.9;
            if (shake < 0.5) shake = 0;
        }

        function drawBackground() {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (gameState === 'PLAYING' && frames % 20 === 0 && score > 50) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                ctx.fillRect(0,0,canvas.width, canvas.height);
            }
            ctx.lineWidth = 1;
            radii.forEach((r, index) => {
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                ctx.stroke();
            });
            ctx.save();
            ctx.shadowBlur = 20 + Math.sin(frames * 0.1) * 10;
            ctx.shadowColor = '#0ff';
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#0ff';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radii[0] * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function draw() {
            ctx.save();
            if (shake > 0) {
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
            }
            drawBackground();
            entities.forEach(e => e.draw());
            if (gameState === 'PLAYING') player.draw();
            particles.forEach(p => p.draw());
            ctx.restore();
        }

        function loop() {
            requestAnimationFrame(loop);
            update();
            draw();
        }

        function handleInput(e) {
            if (e.target.tagName === 'BUTTON' || e.target.closest('.menu-screen')) return;
            if (gameState !== 'PLAYING') return;
            if (e.type === 'touchstart') e.preventDefault();
            let x;
            if (e.type === 'touchstart') {
                x = e.changedTouches[0].clientX;
            } else {
                x = e.clientX;
            }
            soundManager.init();
            if (x < window.innerWidth / 2) {
                player.move(-1); 
            } else {
                player.move(1); 
            }
        }

        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', handleInput, {passive: false});
        window.addEventListener('keydown', (e) => {
            if (gameState === 'PLAYING') {
                if (e.code === 'ArrowLeft') player.move(-1);
                if (e.code === 'ArrowRight') player.move(1);
            }
        });
        
        const btns = [startBtn, restartBtn];
        btns.forEach(btn => {
            btn.addEventListener('click', (e) => { e.stopPropagation(); initGame(); });
            btn.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); initGame(); });
        });

        // Fix botones IA
        [generateMissionBtn, analyzeBtn].forEach(btn => {
            btn.addEventListener('touchstart', (e) => e.stopPropagation(), {passive: false});
        });

        loop();

    </script>
</body>
</html>
