<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Configuración Vital para Móviles -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <title>Neon Orbit: Final</title>
    <link rel="manifest" href="manifest.json">
    
    <!-- Icono Base64 para que se vea bien al instalar -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%23000'/><circle cx='256' cy='256' r='200' stroke='%230ff' stroke-width='20' fill='none'/><circle cx='256' cy='256' r='120' stroke='%230ff' stroke-width='10' fill='none' opacity='0.5'/><circle cx='256' cy='100' r='30' fill='%230ff'/></svg>">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Superior */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            z-index: 10;
        }

        .score-display {
            color: #fff;
            font-size: 28px;
            text-shadow: 0 0 10px #0ff;
            font-weight: bold;
        }

        .hints {
            display: flex;
            justify-content: space-between;
            width: 100%;
            color: rgba(0, 255, 255, 0.4);
            font-size: 12px;
        }

        /* Pantallas de Menú */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: auto;
            transition: opacity 0.3s;
            backdrop-filter: blur(8px);
            padding: 20px;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            color: #0ff;
            font-size: 42px;
            margin: 0 0 20px 0;
            text-shadow: 0 0 20px #0ff;
            text-align: center;
            line-height: 1;
        }
        h1 span { color: #f05; font-size: 24px; letter-spacing: 6px; display: block; margin-top: 5px; }

        .status-box {
            width: 100%;
            max-width: 300px;
            border-left: 4px solid #0ff;
            background: rgba(0, 255, 255, 0.1);
            color: #dff;
            padding: 15px;
            margin-bottom: 30px;
            font-family: monospace;
            font-size: 14px;
            text-align: left;
        }

        button {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 18px 40px;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            text-transform: uppercase;
            margin-top: 10px;
        }

        button:active { background: #0ff; color: #000; transform: scale(0.95); }

        .controls-guide {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 300px;
        }
        .c-box {
            border: 1px solid #333;
            color: #888;
            padding: 10px;
            flex: 1;
            text-align: center;
            font-size: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="score-display">SCORE: <span id="scoreEl">0</span></div>
        <div class="hints">
            <span>&lt; IZQUIERDA</span>
            <span>DERECHA &gt;</span>
        </div>
    </div>

    <div id="startMenu" class="menu-screen">
        <h1>NEON<br><span>TRINITY</span></h1>
        <div class="status-box" id="startMsg">SISTEMA: ONLINE.<br>Modo: Caza Continua.</div>
        <div class="controls-guide">
            <div class="c-box">TOQUE IZQ<br>Bajar</div>
            <div class="c-box">TOQUE DER<br>Subir</div>
        </div>
        <button id="startBtn">JUGAR</button>
    </div>

    <div id="gameOverMenu" class="menu-screen hidden">
        <h1 style="color: #f05; text-shadow: 0 0 20px #f05;">ERROR<br><span style="color:#fff; font-size:20px;">CRÍTICO</span></h1>
        <div class="status-box" style="border-color: #f05; color: #fdd;" id="overMsg">Calculando...</div>
        <div style="font-size: 20px; color: #fff; margin-bottom: 20px;">SCORE FINAL: <span id="finalScore">0</span></div>
        <button id="restartBtn" style="border-color: #f05; color: #f05; box-shadow: 0 0 15px #f05;">REINTENTAR</button>
    </div>

    <script>
        // IIFE para proteger variables
        (function() { 
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            const ui = {
                startMenu: document.getElementById('startMenu'),
                gameOverMenu: document.getElementById('gameOverMenu'),
                scoreEl: document.getElementById('scoreEl'),
                finalScoreEl: document.getElementById('finalScore'),
                startMsg: document.getElementById('startMsg'),
                overMsg: document.getElementById('overMsg'),
                startBtn: document.getElementById('startBtn'),
                restartBtn: document.getElementById('restartBtn')
            };

            let gameState = 'MENU';
            let score = 0;
            let frames = 0;
            let W, H, CX, CY;
            let radii = [];
            
            const aiDb = {
                intro: ["Las monedas persisten.", "Si fallas, da la vuelta.", "Cuidado con los muros."],
                win: ["Recolección eficiente.", "Algoritmo maestro.", "Sincronización total."],
                fail: ["Choque detectado.", "Trayectoria errónea.", "Reiniciando núcleo."]
            };

            // --- SISTEMA DE AUDIO ---
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            let actx;
            const audio = {
                init: () => { if (!actx) actx = new AudioContext(); if (actx.state === 'suspended') actx.resume(); },
                play: (f, t, d) => { 
                    if(!actx)return; 
                    const o=actx.createOscillator(), g=actx.createGain(); 
                    o.type=t; o.frequency.value=f; 
                    g.gain.value=0.1; 
                    g.gain.exponentialRampToValueAtTime(0.01, actx.currentTime+d); 
                    o.connect(g); g.connect(actx.destination); 
                    o.start(); o.stop(actx.currentTime+d); 
                },
                jump: (u) => audio.play(u?600:300,'sine',0.1),
                coin: () => { audio.play(1200,'square',0.05); setTimeout(()=>audio.play(1800,'square',0.1),50); },
                crash: () => audio.play(100,'sawtooth',0.4)
            };

            // --- REDIMENSIONADO ---
            function resize() {
                W = canvas.width = window.innerWidth;
                H = canvas.height = window.innerHeight;
                CX = W / 2;
                CY = H / 2;
                const m = Math.min(W, H);
                radii = [m * 0.20, m * 0.32, m * 0.44];
            }
            window.addEventListener('resize', resize);
            resize();

            // --- JUGADOR ---
            class Player {
                constructor() {
                    this.angle = 0;
                    this.lane = 1;
                    this.currR = radii[1];
                    this.trail = [];
                    this.rotationSpeed = 0.04;
                }
                update() {
                    this.rotationSpeed = 0.04 + (score * 0.00005); // Aceleración muy leve
                    this.angle += this.rotationSpeed;
                    this.currR += (radii[this.lane] - this.currR) * 0.25;
                    this.x = CX + Math.cos(this.angle) * this.currR;
                    this.y = CY + Math.sin(this.angle) * this.currR;
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > 12) this.trail.shift();
                }
                move(dir) {
                    const old = this.lane;
                    this.lane += dir;
                    if (this.lane < 0) this.lane = 0;
                    if (this.lane > 2) this.lane = 2;
                    if (this.lane !== old) audio.jump(dir > 0);
                }
                draw() {
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    this.trail.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
                    ctx.stroke();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 6, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            // Variables de Entidades
            let player;
            let obstacles = [];
            let coins = [];
            let particles = [];
            let lastEnemyLane = -1; 

            function init() {
                audio.init();
                score = 0;
                frames = 0;
                lastEnemyLane = -1;
                ui.scoreEl.innerText = 0;
                player = new Player();
                obstacles = [];
                coins = [];
                particles = [];
                gameState = 'PLAYING';
                ui.startMenu.classList.add('hidden');
                ui.gameOverMenu.classList.add('hidden');
                loop();
            }

            // --- GENERADOR DE OBSTÁCULOS ---
            function spawnObstacles() {
                const MIN_RATE = 25;
                const START_RATE = 80; 
                const spawnRate = Math.max(MIN_RATE, START_RATE - score); 
                
                if (frames % spawnRate === 0) {
                    const targetAngle = player.angle + Math.PI; 
                    
                    // Evitar solapar con monedas
                    const tooCloseCoin = coins.some(c => {
                        const r = radii[c.lane];
                        const ox = CX + Math.cos(targetAngle) * radii[c.lane]; 
                        const oy = CY + Math.sin(targetAngle) * radii[c.lane];
                        const cx = CX + Math.cos(c.angle) * r;
                        const cy = CY + Math.sin(c.angle) * r;
                        return Math.hypot(ox - cx, oy - cy) < 40;
                    });
                    
                    if (tooCloseCoin) return; 

                    // Lógica de carril justo
                    let lane = Math.floor(Math.random() * 3);
                    if (lastEnemyLane !== -1) {
                        if (lastEnemyLane === 1) {
                            lane = Math.random() < 0.5 ? 0 : 2; 
                        } else if (Math.random() < 0.3) {
                            lane = 1;
                        }
                    }
                    lastEnemyLane = lane;

                    obstacles.push({
                        angle: targetAngle,
                        lane: lane,
                        active: true
                    });
                }
            }

            // --- GESTOR DE MONEDAS (SNAKE) ---
            function manageCoins() {
                if (coins.length === 0) {
                    // Aleatoriedad: 90 a 270 grados frente al jugador
                    const randomOffset = (Math.random() * Math.PI) + (Math.PI / 2);
                    const spawnAngle = player.angle + randomOffset;
                    
                    // Buscar carril libre
                    const lanes = [0, 1, 2].sort(() => Math.random() - 0.5);
                    
                    for (let lane of lanes) {
                        const busy = obstacles.some(o => 
                            o.active && 
                            Math.abs(o.angle - spawnAngle) < 0.5 && 
                            o.lane === lane
                        );

                        if (!busy) {
                            coins.push({
                                angle: spawnAngle,
                                lane: lane,
                                active: true
                            });
                            break; 
                        }
                    }
                }
            }

            function update() {
                if (gameState !== 'PLAYING') return;
                frames++;
                player.update();
                
                spawnObstacles();
                manageCoins();

                // Limpieza de Obstáculos (si quedan atrás)
                const SAFE_ZONE = Math.PI * 2; 
                obstacles = obstacles.filter(e => {
                    return e.active && (e.angle > player.angle - SAFE_ZONE);
                });

                // Chequeo de Colisiones
                const checkHit = (entity, isCoin) => {
                    const r = radii[entity.lane];
                    const ex = CX + Math.cos(entity.angle) * r;
                    const ey = CY + Math.sin(entity.angle) * r;
                    const dist = Math.hypot(player.x - ex, player.y - ey);

                    if (dist < 20) {
                        if (isCoin) {
                            score += 1;
                            ui.scoreEl.innerText = score;
                            audio.coin();
                            createParticles(ex, ey, '#ff0');
                            // Remover moneda
                            const idx = coins.indexOf(entity);
                            if (idx > -1) coins.splice(idx, 1);
                        } else {
                            audio.crash();
                            createParticles(ex, ey, '#f05');
                            gameOver();
                            entity.active = false;
                        }
                    }
                };

                obstacles.forEach(o => checkHit(o, false));
                coins.forEach(c => checkHit(c, true));
                
                particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; });
                particles = particles.filter(p => p.life > 0);
            }

            function createParticles(x, y, color) {
                for(let i=0; i<8; i++) {
                    particles.push({
                        x, y, color,
                        vx: (Math.random()-0.5)*8,
                        vy: (Math.random()-0.5)*8,
                        life: 1
                    });
                }
            }

            function draw() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, W, H);
                
                ctx.lineWidth = 2;
                radii.forEach((r, i) => {
                    ctx.beginPath();
                    ctx.arc(CX, CY, r, 0, Math.PI*2);
                    ctx.strokeStyle = i===1 ? 'rgba(0,255,255,0.3)' : 'rgba(0,255,255,0.15)';
                    ctx.stroke();
                });

                if (gameState === 'PLAYING') {
                    // Monedas
                    coins.forEach(c => {
                        const r = radii[c.lane];
                        const ex = CX + Math.cos(c.angle) * r;
                        const ey = CY + Math.sin(c.angle) * r;
                        
                        ctx.fillStyle = '#ff0';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff0';
                        ctx.beginPath();
                        ctx.arc(ex, ey, 6, 0, Math.PI*2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    });

                    // Obstáculos
                    obstacles.forEach(o => {
                        if (!o.active) return;
                        const r = radii[o.lane];
                        const ex = CX + Math.cos(o.angle) * r;
                        const ey = CY + Math.sin(o.angle) * r;
                        
                        ctx.fillStyle = '#f05';
                        ctx.beginPath();
                        ctx.save();
                        ctx.translate(ex, ey);
                        ctx.rotate(o.angle + Math.PI/4);
                        ctx.rect(-6, -6, 12, 12);
                        ctx.restore();
                        ctx.fill();
                    });

                    // Jugador
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#0ff';
                    player.draw();
                    ctx.shadowBlur = 0;

                    // Partículas
                    particles.forEach(p => {
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1;
                }
            }

            function gameOver() {
                gameState = 'GAMEOVER';
                ui.finalScoreEl.innerText = score;
                ui.overMsg.innerText = aiDb.fail[Math.floor(Math.random()*aiDb.fail.length)];
                ui.gameOverMenu.classList.remove('hidden');
            }

            function loop() {
                if (gameState === 'PLAYING') requestAnimationFrame(loop);
                update();
                draw();
            }

            function handleInput(x) {
                if (gameState !== 'PLAYING') return;
                audio.init();
                if (x < W / 2) player.move(-1);
                else player.move(1);
            }

            window.addEventListener('mousedown', e => handleInput(e.clientX));
            window.addEventListener('touchstart', e => {
                if(e.target.tagName === 'BUTTON') return;
                e.preventDefault();
                handleInput(e.changedTouches[0].clientX);
            }, {passive: false});

            ui.startBtn.addEventListener('click', init);
            ui.restartBtn.addEventListener('click', init);
            ui.startBtn.addEventListener('touchstart', (e)=>{e.stopPropagation();init();});
            ui.restartBtn.addEventListener('touchstart', (e)=>{e.stopPropagation();init();});

            ui.startMsg.innerHTML = "SISTEMA: ONLINE.<br>" + aiDb.intro[Math.floor(Math.random()*aiDb.intro.length)];
            draw();
        })();
    </script>
</body>
</html>
