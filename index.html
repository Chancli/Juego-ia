<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <title>Neon Orbit: Radio</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%23000'/><circle cx='256' cy='256' r='200' stroke='%230ff' stroke-width='20' fill='none'/><circle cx='256' cy='256' r='120' stroke='%230ff' stroke-width='10' fill='none' opacity='0.5'/><circle cx='256' cy='100' r='30' fill='%230ff'/></svg>">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; touch-action: none; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: 'Orbitron', sans-serif; }
        #gameCanvas { display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI General */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; padding-top: max(20px, env(safe-area-inset-top)); padding-bottom: max(20px, env(safe-area-inset-bottom)); z-index: 10; }
        .score-display { color: #fff; font-size: 28px; text-shadow: 0 0 10px #0ff; font-weight: bold; }
        .hints { display: flex; justify-content: space-between; width: 100%; color: rgba(0, 255, 255, 0.4); font-size: 12px; }
        
        /* Men煤s */
        .menu-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.92); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; transition: opacity 0.3s; backdrop-filter: blur(8px); padding: 20px; overflow-y: auto; }
        .hidden { opacity: 0; pointer-events: none; z-index: 0; }
        
        h1 { color: #0ff; font-size: 42px; margin: 20px 0 10px 0; text-shadow: 0 0 20px #0ff; text-align: center; line-height: 1; }
        h1 span { color: #f05; font-size: 24px; letter-spacing: 6px; display: block; margin-top: 5px; }
        
        .status-box { width: 100%; max-width: 300px; border-left: 4px solid #0ff; background: rgba(0, 255, 255, 0.1); color: #dff; padding: 10px; margin-bottom: 15px; font-family: monospace; font-size: 12px; text-align: left; }
        
        button { background: transparent; color: #0ff; border: 2px solid #0ff; padding: 15px 30px; font-size: 16px; font-family: 'Orbitron', sans-serif; font-weight: bold; cursor: pointer; box-shadow: 0 0 15px rgba(0, 255, 255, 0.3); border-radius: 4px; text-transform: uppercase; margin-top: 10px; width: 100%; max-width: 300px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; pointer-events: auto; }
        button:active { background: #0ff; color: #000; transform: scale(0.95); }
        
        .section-title { color: #888; font-size: 10px; margin: 10px 0 5px 0; letter-spacing: 2px; }
        
        .file-btn { border-color: #f0f; color: #f0f; box-shadow: 0 0 10px rgba(255, 0, 255, 0.3); font-size: 14px; margin-bottom: 5px; }
        .radio-btn { border-color: #0f0; color: #0f0; box-shadow: 0 0 10px rgba(0, 255, 0, 0.3); font-size: 12px; margin-bottom: 5px; padding: 10px; }
        
        #fileInput { display: none; }
        #urlInput { width: 100%; max-width: 300px; background: #111; border: 1px solid #333; color: #fff; padding: 10px; margin-bottom: 10px; border-radius: 4px; font-family: monospace; }

        .orbit-selector { display: flex; gap: 10px; margin-bottom: 20px; pointer-events: auto; }
        .orbit-btn { padding: 10px; font-size: 14px; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; border: 1px solid #555; color: #555; box-shadow: none; margin: 0; cursor: pointer; }
        .orbit-btn.active { border-color: #0ff; color: #0ff; box-shadow: 0 0 10px #0ff; background: rgba(0, 255, 255, 0.1); }

        .controls-guide { display: flex; gap: 20px; margin-bottom: 20px; width: 100%; max-width: 300px; }
        .c-box { border: 1px solid #333; color: #888; padding: 10px; flex: 1; text-align: center; font-size: 10px; border-radius: 4px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui-layer">
        <div class="score-display">SCORE: <span id="scoreEl">0</span></div>
        <div class="hints"><span>&lt; IZQUIERDA</span><span>DERECHA &gt;</span></div>
    </div>

    <!-- MEN INICIAL -->
    <div id="startMenu" class="menu-screen">
        <h1>NEON<br><span>RADIO</span></h1>
        <div class="status-box" id="startMsg">MODO: RADIO ONLINE.<br>Sincronizando frecuencias...</div>
        
        <div class="section-title">DISEO DE PISTA</div>
        <div class="orbit-selector">
            <button class="orbit-btn" id="orb2">2</button>
            <button class="orbit-btn active" id="orb3">3</button>
            <button class="orbit-btn" id="orb4">4</button>
        </div>

        <!-- SECCIN MP3 -->
        <div class="section-title">OPCIN A: ARCHIVO LOCAL</div>
        <input type="file" id="fileInput" accept="audio/*">
        <button id="loadBtn" class="file-btn"> CARGAR MP3</button>

        <!-- SECCIN RADIO -->
        <div class="section-title">OPCIN B: RADIO LIVE</div>
        <input type="text" id="urlInput" placeholder="Pega URL de Stream aqu铆...">
        <button id="radioCustomBtn" class="radio-btn"> CONECTAR URL</button>
        
        <div style="display:flex; gap:5px; width:100%; max-width:300px;">
            <button id="radio1Btn" class="radio-btn" style="flex:1;"> Gaming</button>
            <button id="radio2Btn" class="radio-btn" style="flex:1;"> Trap</button>
        </div>

        <button id="startBtn" style="margin-top: 20px; border-color: #fff; color: #fff;">JUGAR (SILENCIO)</button>
        <br><br> <!-- Espacio extra para scroll -->
    </div>

    <!-- MEN GAME OVER -->
    <div id="gameOverMenu" class="menu-screen hidden">
        <h1 style="color: #f05; text-shadow: 0 0 20px #f05;">FIN DE<br><span style="color:#fff; font-size:20px;">TRANSMISIN</span></h1>
        <div class="status-box" style="border-color: #f05; color: #fdd;" id="overMsg">Se帽al perdida...</div>
        <div style="font-size: 20px; color: #fff; margin-bottom: 20px;">SCORE FINAL: <span id="finalScore">0</span></div>
        
        <button id="restartBtn" style="border-color: #f05; color: #f05; box-shadow: 0 0 15px #f05;">REINTENTAR</button>
        <button id="backMenuBtn" style="border-color: #fff; color: #fff; font-size: 12px; margin-top: 10px;">VOLVER AL MEN</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas=document.getElementById('gameCanvas'),ctx=canvas.getContext('2d');
            const ui={
                startMenu:document.getElementById('startMenu'),gameOverMenu:document.getElementById('gameOverMenu'),
                scoreEl:document.getElementById('scoreEl'),finalScoreEl:document.getElementById('finalScore'),
                startMsg:document.getElementById('startMsg'),overMsg:document.getElementById('overMsg'),
                startBtn:document.getElementById('startBtn'),restartBtn:document.getElementById('restartBtn'),
                backMenuBtn:document.getElementById('backMenuBtn'),
                loadBtn:document.getElementById('loadBtn'),fileInput:document.getElementById('fileInput'),
                urlInput:document.getElementById('urlInput'),
                radioCustomBtn:document.getElementById('radioCustomBtn'),
                radio1Btn:document.getElementById('radio1Btn'),
                radio2Btn:document.getElementById('radio2Btn'),
                orbBtns: [document.getElementById('orb2'), document.getElementById('orb3'), document.getElementById('orb4')]
            };
            
            let gameState='MENU',score=0,frames=0,W,H,CX,CY;
            let laneCount = 3;
            let radii=[], baseRadii=[];
            
            const aiDb={intro:["Sintonizando frecuencia...","Se帽al en vivo.","Cuidado con la interferencia."],win:["Transmisi贸n completada."],fail:["Se帽al interrumpida."]};
            
            const AudioContext=window.AudioContext||window.webkitAudioContext;
            let actx, analyser, dataArray, sourceNode;
            let audioEl; // Elemento HTML Audio para radio
            
            let rawBass = 0;
            let kickValue = 0; 
            let beatDetected = false;
            let isMusicLoaded = false;
            let volHistory = [];
            let framesSinceSpawn = 0;
            let pendingSpawn = false;

            // URLs de Radio (Streams que suelen permitir CORS o funcionar bien)
            const RADIOS = {
                gaming: "https://stream.zeno.fm/0r0xa792kwzuv", // Gaming Radio gen茅rica
                trap: "https://stream.zeno.fm/f3wvbbqmdg8uv"   // Trap/Phonk Radio gen茅rica
            };

            const audio={
                init:()=>{if(!actx)actx=new AudioContext();if(actx.state==='suspended')actx.resume();},
                
                // Efectos
                playSfx:(f,t,d)=>{if(!actx)return;const o=actx.createOscillator(),g=actx.createGain();o.type=t;o.frequency.value=f;g.gain.value=0.1;g.gain.exponentialRampToValueAtTime(0.01,actx.currentTime+d);o.connect(g);g.connect(actx.destination);o.start();o.stop(actx.currentTime+d);},
                jump:(u)=>audio.playSfx(u?600:300,'sine',0.1),
                coin:()=>{audio.playSfx(1200,'square',0.05);setTimeout(()=>audio.playSfx(1800,'square',0.1),50);},
                crash:()=>audio.playSfx(100,'sawtooth',0.4),

                // RESET TOTAL DE AUDIO (Importante para cambiar fuentes)
                reset: () => {
                    if(sourceNode) { try{sourceNode.disconnect();}catch(e){} }
                    if(audioEl) { audioEl.pause(); audioEl.src = ""; audioEl = null; }
                    isMusicLoaded = false;
                },

                // MODO 1: ARCHIVO LOCAL
                handleFileSelect: (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    audio.init();
                    audio.reset();
                    ui.loadBtn.innerText = "DECODIFICANDO...";
                    
                    const reader = new FileReader();
                    reader.onload = function(ev) {
                        actx.decodeAudioData(ev.target.result, function(buffer) {
                            // Crear Buffer Source
                            sourceNode = actx.createBufferSource();
                            sourceNode.buffer = buffer;
                            sourceNode.loop = true;
                            
                            // Conectar
                            analyser = actx.createAnalyser();
                            analyser.fftSize = 256; 
                            sourceNode.connect(analyser);
                            analyser.connect(actx.destination);
                            
                            dataArray = new Uint8Array(analyser.frequencyBinCount);
                            isMusicLoaded = true;
                            
                            ui.loadBtn.innerText = "LISTO: " + file.name.substring(0,10)+"...";
                            ui.startBtn.innerText = "JUGAR (MP3)";
                            ui.startMsg.innerText = "MP3 Cargado Correctamente.";
                        }, function(e){ ui.loadBtn.innerText = "ERROR"; });
                    };
                    reader.readAsArrayBuffer(file);
                },

                // MODO 2: RADIO ONLINE (STREAM)
                playRadio: (url) => {
                    audio.init();
                    audio.reset();
                    ui.startMsg.innerText = "CONECTANDO RADIO...";
                    
                    // Crear elemento de audio HTML5
                    audioEl = new Audio();
                    audioEl.crossOrigin = "anonymous"; // CRTICO PARA VISUALIZAR
                    audioEl.src = url;
                    
                    // Crear Source desde el elemento
                    sourceNode = actx.createMediaElementSource(audioEl);
                    analyser = actx.createAnalyser();
                    analyser.fftSize = 256;
                    
                    sourceNode.connect(analyser);
                    analyser.connect(actx.destination);
                    
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                    
                    // Intentar reproducir
                    audioEl.play().then(() => {
                        isMusicLoaded = true;
                        ui.startMsg.innerText = "RADIO CONECTADA ";
                        ui.startBtn.innerText = "JUGAR (EN VIVO)";
                    }).catch(e => {
                        console.error(e);
                        ui.startMsg.innerText = "ERROR: La radio bloque贸 la visualizaci贸n (CORS).";
                    });
                },

                startPlayback: () => {
                    if(sourceNode && sourceNode.start) sourceNode.start(0); // Para Buffer (MP3)
                    if(audioEl) audioEl.play(); // Para Radio
                },

                stopPlayback: () => {
                    if(sourceNode && sourceNode.stop) try{sourceNode.stop();}catch(e){}
                    if(audioEl) audioEl.pause();
                },
                
                analyze: () => {
                    if (!analyser) return;
                    analyser.getByteFrequencyData(dataArray);
                    
                    let sum = 0;
                    // Analizar bajos
                    for(let i = 0; i < 5; i++) sum += dataArray[i];
                    rawBass = sum / 5;
                    
                    // Auto-Gain
                    if(volHistory.length > 60) volHistory.shift();
                    volHistory.push(rawBass);
                    const maxRecent = Math.max(...volHistory, 100);
                    
                    const normalizedBass = Math.max(0, (rawBass - 80) / (maxRecent * 0.8));

                    if (normalizedBass > kickValue) kickValue = normalizedBass; 
                    else kickValue *= 0.90; 

                    beatDetected = (normalizedBass > 0.75);
                }
            };

            function updateRadii() {
                W=canvas.width; H=canvas.height;
                CX=W/2; CY=H/2;
                const m = Math.min(W,H);
                baseRadii = [];
                const startR = m * 0.18;
                const space = (m * 0.45 - startR) / (laneCount - 1 || 1); 
                for(let i=0; i<laneCount; i++) {
                    baseRadii.push(startR + (i * space));
                }
                radii = [...baseRadii];
            }

            function resize(){
                canvas.width=window.innerWidth;
                canvas.height=window.innerHeight;
                updateRadii();
            }
            window.addEventListener('resize',resize);resize();

            class Player{constructor(){
                this.angle=0;
                this.lane= Math.floor(laneCount / 2); 
                this.currR=radii[this.lane];
                this.trail=[];
                this.rotationSpeed=0.04;
            }update(){
                this.rotationSpeed=0.04+(score*0.00005);
                this.angle+=this.rotationSpeed;
                const targetR = radii[this.lane];
                this.currR += (targetR - this.currR) * 0.25;
                this.x=CX+Math.cos(this.angle)*this.currR;
                this.y=CY+Math.sin(this.angle)*this.currR;
                this.trail.push({x:this.x,y:this.y});
                if(this.trail.length>12)this.trail.shift();
            }move(d){
                const old=this.lane;
                this.lane+=d;
                if(this.lane < 0) this.lane = 0;
                if(this.lane >= laneCount) this.lane = laneCount - 1;
                if(this.lane!==old)audio.jump(d>0);
            }draw(){ctx.strokeStyle='#0ff';ctx.lineWidth=4;ctx.lineCap='round';ctx.beginPath();this.trail.forEach((p,i)=>i===0?ctx.moveTo(p.x,p.y):ctx.lineTo(p.x,p.y));ctx.stroke();ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(this.x,this.y,6,0,Math.PI*2);ctx.fill();}}
            
            let player,obstacles=[],coins=[],particles=[],lastEnemyLane=-1;

            function init(){
                if(isMusicLoaded) audio.startPlayback(); // Iniciar el audio preparado
                else audio.init(); // O iniciar silencio
                
                score=0;frames=0;framesSinceSpawn=0;lastEnemyLane=-1;
                ui.scoreEl.innerText=0;player=new Player();obstacles=[];coins=[];particles=[];
                gameState='PLAYING';
                ui.startMenu.classList.add('hidden');
                ui.gameOverMenu.classList.add('hidden');
                loop();
            }
            
            function checkSpawn(){
                const MIN_RATE = 60, START_RATE = 130;
                const targetRate = Math.max(MIN_RATE, START_RATE - Math.floor(score/2));
                framesSinceSpawn++;
                if (framesSinceSpawn > targetRate) pendingSpawn = true;

                let doSpawn = false;
                if (pendingSpawn) {
                    if (isMusicLoaded) {
                        if (beatDetected || framesSinceSpawn > targetRate + 40) doSpawn = true;
                    } else {
                        doSpawn = true;
                    }
                }

                if (doSpawn) {
                    spawnEnemy();
                    framesSinceSpawn = 0;
                    pendingSpawn = false;
                }
            }

            function spawnEnemy() {
                const TRAVEL_TIME_FRAMES = 80; 
                const travelDistance = player.rotationSpeed * TRAVEL_TIME_FRAMES;
                const targetAngle = player.angle + travelDistance;
                if(coins.some(c => Math.abs(c.angle - targetAngle) < 0.5)) return;

                let lane=Math.floor(Math.random() * laneCount); 
                if(lastEnemyLane!==-1 && laneCount > 1){
                    if(Math.random() < 0.6) {
                        while(lane === lastEnemyLane) lane=Math.floor(Math.random() * laneCount);
                    }
                }
                lastEnemyLane=lane;
                const isJumper = (score > 5) && (Math.random() < 0.25); // Jumper balanceado

                obstacles.push({
                    angle: targetAngle,
                    lane: lane,
                    currentRadius: radii[lane],
                    active: true,
                    jumpTimer: 0,
                    isJumper: isJumper,
                    // Datos para boomerang
                    originalLane: lane,
                    jumpPhase: 0
                });
            }

            function manageCoins(){
                if(coins.length===0){
                    const spawnAngle=player.angle+(Math.PI * 1.3);
                    const lanes = Array.from({length: laneCount}, (_, i) => i).sort(()=>Math.random()-0.5);
                    for(let lane of lanes){
                        const busy=obstacles.some(o=>o.active&&Math.abs(o.angle-spawnAngle)<0.5&&o.lane===lane);
                        if(!busy){
                            coins.push({angle:spawnAngle,lane:lane,active:true});
                            break;
                        }
                    }
                }
            }
            
            function update(){
                if(gameState!=='PLAYING')return;
                frames++;
                if(isMusicLoaded) audio.analyze();

                const expansion = kickValue * 18; 
                radii = baseRadii.map(r => r + expansion);

                player.update();
                checkSpawn();
                manageCoins();

                obstacles.forEach(o => {
                    if(!o.active) return;
                    
                    // L贸gica Boomerang / Jumper
                    if(o.isJumper && beatDetected && isMusicLoaded && o.jumpTimer === 0){
                        if(o.jumpPhase === 0 && Math.random() < 0.5) { // IDA
                            const possibleLanes = [];
                            if(o.lane > 0) possibleLanes.push(o.lane - 1);
                            if(o.lane < laneCount - 1) possibleLanes.push(o.lane + 1);
                            
                            if(possibleLanes.length > 0) {
                                o.lane = possibleLanes[Math.floor(Math.random() * possibleLanes.length)];
                                const ex=CX+Math.cos(o.angle)*o.currentRadius, ey=CY+Math.sin(o.angle)*o.currentRadius;
                                createParticles(ex, ey, '#f80'); 
                                o.jumpPhase = 1;
                                o.jumpTimer = 40; 
                            }
                        } else if(o.jumpPhase === 1) { // VUELTA
                            o.lane = o.originalLane;
                            const ex=CX+Math.cos(o.angle)*o.currentRadius, ey=CY+Math.sin(o.angle)*o.currentRadius;
                            createParticles(ex, ey, '#f80'); 
                            o.jumpPhase = 2;
                            o.jumpTimer = 999;
                        }
                    }
                    if(o.jumpTimer > 0) o.jumpTimer--;

                    const targetR = radii[o.lane];
                    o.currentRadius += (targetR - o.currentRadius) * 0.2;
                });

                const SAFE_ZONE=Math.PI*2; 
                obstacles=obstacles.filter(e=>e.active&&(e.angle>player.angle-SAFE_ZONE));
                
                const checkHit=(e,isCoin)=>{
                    const r = isCoin ? radii[e.lane] : e.currentRadius; 
                    const ex=CX+Math.cos(e.angle)*r,ey=CY+Math.sin(e.angle)*r,dist=Math.hypot(player.x-ex,player.y-ey);
                    if(dist<20){
                        if(isCoin){
                            score+=1;ui.scoreEl.innerText=score;audio.coin();createParticles(ex,ey,'#ff0');
                            const idx=coins.indexOf(e);if(idx>-1)coins.splice(idx,1);
                        }else{
                            audio.crash();createParticles(ex,ey, e.isJumper ? '#f80' : '#f05');gameOver();e.active=false;
                        }
                    }
                };
                obstacles.forEach(o=>checkHit(o,false));coins.forEach(c=>checkHit(c,true));
                particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life-=0.05;});particles=particles.filter(p=>p.life>0);
            }
            
            function createParticles(x,y,color){for(let i=0;i<8;i++)particles.push({x,y,color,vx:(Math.random()-0.5)*8,vy:(Math.random()-0.5)*8,life:1});}
            
            function draw(){
                if (kickValue > 0.8 && gameState === 'PLAYING') ctx.fillStyle = 'rgba(20, 0, 30, 0.6)'; 
                else ctx.fillStyle = '#000';
                ctx.fillRect(0,0,W,H);
                
                if(isMusicLoaded) {
                    const coreSize = 15 + (kickValue * 30); 
                    const coreAlpha = 0.3 + (kickValue * 0.5);
                    const grd = ctx.createRadialGradient(CX, CY, 5, CX, CY, coreSize * 3);
                    grd.addColorStop(0, `rgba(255, 0, 255, ${coreAlpha})`);
                    grd.addColorStop(1, "rgba(0,0,0,0)");
                    ctx.fillStyle = grd;
                    ctx.beginPath(); ctx.arc(CX, CY, coreSize * 3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(CX, CY, coreSize * 0.8, 0, Math.PI*2); ctx.fill();
                }

                ctx.lineWidth=2;
                radii.forEach((r,i)=>{
                    ctx.beginPath();ctx.arc(CX,CY,r,0,Math.PI*2);
                    const glow = 0.3 + (kickValue * 0.7); 
                    ctx.strokeStyle=i===1?`rgba(0,255,255,${glow*1.5})` : `rgba(0,255,255,${glow})`;
                    ctx.shadowBlur = kickValue * 20; ctx.shadowColor = '#0ff';
                    ctx.stroke();ctx.shadowBlur = 0;
                });
                
                if(gameState==='PLAYING'){
                    coins.forEach(c=>{const r=radii[c.lane],ex=CX+Math.cos(c.angle)*r,ey=CY+Math.sin(c.angle)*r;ctx.fillStyle='#ff0';ctx.shadowBlur=15+(kickValue*20);ctx.shadowColor='#ff0';ctx.beginPath();ctx.arc(ex,ey,6+(kickValue*4),0,Math.PI*2);ctx.fill();ctx.shadowBlur=0;});
                    
                    obstacles.forEach(o=>{if(!o.active)return;
                        const r=o.currentRadius; 
                        const ex=CX+Math.cos(o.angle)*r,ey=CY+Math.sin(o.angle)*r;
                        const baseColor = o.isJumper ? 30 : 340; 
                        const glowColor = o.isJumper ? '#f80' : '#f05';
                        const enemyGlow = 15 + (kickValue * 40);
                        ctx.fillStyle = `hsl(${baseColor}, 100%, ${60 + kickValue*20}%)`; 
                        ctx.shadowBlur = enemyGlow; ctx.shadowColor = glowColor;
                        ctx.beginPath();ctx.save();ctx.translate(ex,ey);ctx.rotate(o.angle+Math.PI/4);
                        const s = 12 + (kickValue * 8); 
                        ctx.rect(-s/2,-s/2,s,s);
                        ctx.restore();ctx.fill();ctx.shadowBlur = 0;
                    });
                    
                    ctx.shadowBlur=20;ctx.shadowColor='#0ff';player.draw();ctx.shadowBlur=0;
                    particles.forEach(p=>{ctx.fillStyle=p.color;ctx.globalAlpha=p.life;ctx.beginPath();ctx.arc(p.x,p.y,3,0,Math.PI*2);ctx.fill();});ctx.globalAlpha=1;
                }
            }
            
            function gameOver(){
                gameState='GAMEOVER';
                audio.stopPlayback(); // Detener radio/mp3
                ui.finalScoreEl.innerText=score;
                ui.overMsg.innerText=aiDb.fail[Math.floor(Math.random()*aiDb.fail.length)];
                ui.gameOverMenu.classList.remove('hidden');
            }
            
            function backToMenu(){
                gameState='MENU';
                ui.gameOverMenu.classList.add('hidden');
                ui.startMenu.classList.remove('hidden');
                audio.stopPlayback();
                ui.startMsg.innerText = "SISTEMA: REINICIADO.";
            }

            function loop(){if(gameState==='PLAYING')requestAnimationFrame(loop);update();draw();}
            function handleInput(x){if(gameState!=='PLAYING')return; if(!isMusicLoaded) audio.init(); if(x<W/2)player.move(-1);else player.move(1);}
            
            window.addEventListener('mousedown',e=>handleInput(e.clientX));
            window.addEventListener('touchstart',e=>{if(e.target.tagName==='BUTTON'||e.target.tagName==='INPUT')return;e.preventDefault();handleInput(e.changedTouches[0].clientX);},{passive:false});
            
            // Eventos de Botones (StopPropagation cr铆tico)
            const bind = (el, fn) => {
                if(!el) return;
                el.addEventListener('click', (e) => { e.stopPropagation(); fn(); });
                el.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); fn(); });
            };

            bind(ui.loadBtn, () => ui.fileInput.click());
            ui.fileInput.addEventListener('change', audio.handleFileSelect);
            
            // Bot贸n de Custom URL
            bind(ui.radioCustomBtn, () => {
                const url = ui.urlInput.value.trim();
                if(url) audio.playRadio(url);
            });

            // Botones de Radio Preset
            bind(ui.radio1Btn, () => audio.playRadio(RADIOS.gaming));
            bind(ui.radio2Btn, () => audio.playRadio(RADIOS.trap));

            bind(ui.startBtn, init);
            bind(ui.restartBtn, init);
            bind(ui.backMenuBtn, backToMenu);

            // Botones de rbitas
            ui.orbBtns.forEach((btn, index) => {
                bind(btn, () => {
                    ui.orbBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    laneCount = index + 2;
                    updateRadii();
                });
            });

            ui.startMsg.innerHTML="SISTEMA: ONLINE.<br>"+aiDb.intro[Math.floor(Math.random()*aiDb.intro.length)];
            updateRadii();
            draw();
        });
    </script>
</body>
</html>
